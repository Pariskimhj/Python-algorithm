#!/usr/bin/env python
# coding: utf-8

# In[17]:


# 문제 출처 : SW Expert Academy

# 카드를 퍼펙트 셔플 한다는 것은, 카드 덱을 정확히 절반으로 나누고 나눈 것들에서 교대로 카드를 뽑아 새로운 덱을 만드는 것을 의미한다. 
# 정확한 방식은 다음 그림과 같다.


# N개의 카드가 있는 덱이 주어질 때 이를 퍼펙트 셔플하면 어떤 순서가 되는지 출력하는 프로그램을 작성하라.
# 만약 N이 홀수이면, 교대로 놓을 때 먼저 놓는 쪽에 한 장이 더 들어가게 하면 된다.


# [입력]

# 첫 번째 줄에 테스트 케이스의 수 T가 주어진다.
# 각 테스트 케이스의 첫 번째 줄에는 자연수 N(1 ≤ N ≤ 1,000)이 주어진다.
# 두 번째 줄에는 덱에 카드가 놓인 순서대로 N개의 카드 이름이 공백으로 구분되어 주어진다.
# 카드의 이름은 알파벳 대문자와 ‘-’만으로 이루어져 있으며, 길이는 80이하이다.

# [출력]

# 각 테스트 케이스마다 주어진 덱을 퍼펙트 셔플한 결과를 한 줄에 카드 이름을 공백으로 구분하여 출력한다.

import math as m                      # math 모듈 불러오기
for t in range(int(input())):         # T 입력 받기
    N = int(input())                  # N 입력 받기
    card = input().split()            # 카드 덱 입력 받기
    f_card = card[:m.ceil(N/2)]       # 첫번째 덱(홀수일 경우 두번째 덱보다 1개 더 많음)
    b_card = card[m.ceil(N/2):]       # 두번째 덱
    final = list(zip(f_card, b_card)) # 첫번째 덱과 두번째 덱을 인덱스별로 묶기
    if N%2 == 0:                      # N이 짝수인 경우
        print(f"#{t+1}",*[b for a in final for b in a]) # 리스트, 튜플 형태를 풀어서 출력
    else:                                               # N이 홀수인 경우
        print(f"#{t+1}",*[b for a in final for b in a]+[f_card[-1]]) # 첫번째 덱과 두번째 덱을 인덱스별로 묶고 첫번째 덱의 마지막 카드 추가

