#!/usr/bin/env python
# coding: utf-8

# In[ ]:


# 출처 : 이것이 코딩 테스트다.

# [큰 수의 법칙]
# 동빈이의 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 때 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다. 
# 단, 배열의 특정한 인덱스(번호)에 해당하는 수가 연속해서 K번을 초과하여 더해질 수 없는 것이 이 법칙의 특징
# 단, 서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다.

# [입력]
# 첫 줄에 N, M, K가 주어짐
# 두번째 줄에 N개의 자연수가 주어진다.

# [출력]
# 동빈이의 큰 수의 법칙에 따라 더해진 답을 출력

# <그리디 알고리즘>

# [큰 수의 법칙 문제 풀이]
# 가장 큰 수가 K번, 두번째로 큰 수가 1번의 형태가 반복된다.
# 가장 큰 수가 나오는 횟수 * 가장 큰 수 + (M - 가장 큰 수가 나오는 횟수) * 두번째로 큰 수

# N, M, K를 공백으로 구분하여 입력받기
n, m, k = map(int, input().split())

# N개의 수를 공백으로 구분하여 입력받기
data = list(map(int, input().split()))

data.sort()                  # 입력받은 N개의 수 정렬(오름차순)
first = data[n-1]            # 가장 큰 수(data의 마지막 수)
second = data[n-2]           # 두번째로 큰 수

# 가장 큰 수가 더해지는 횟수
count = int(m/(k+1)) * k     # 수열 내부에서 first의 개수 / 수열(first*k + second)의 수 * k
count += m % (K+1)           # m에서 수열 자리를 빼고 남은 first 자리 / m을 (K+1)로 나눈 나머지

result = 0                   # result 초기화
result+=(count) * first      # 가장 큰 수 더하기 / 가장 큰 수가 더해지는 횟수 * 가장 큰 수
result+=(m - count) * second # 두번째로 큰 수 더하기 / 두번째로 큰 수가 더해지는 횟수 * 두번째로 큰 수

print(result)                # 결과 출력

